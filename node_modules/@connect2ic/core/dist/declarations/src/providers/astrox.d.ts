import type { IDL } from "@dfinity/candid";
import type { ActorSubclass } from "@dfinity/agent";
import type { IConnector, IWalletConnector } from "./connectors";
import { Result } from "neverthrow";
import { BalanceError, ConnectError, CreateActorError, DisconnectError, InitError, TransferError } from "./connectors";
import { DelegationMode } from "@astrox/sdk-web/build/types";
declare class AstroX implements IConnector, IWalletConnector {
    #private;
    meta: {
        features: string[];
        icon: {
            light: any;
            dark: any;
        };
        id: string;
        name: string;
    };
    get principal(): string | undefined;
    get wallets(): {
        principal: string;
        accountId: string;
    }[];
    constructor(userConfig?: {});
    set config(config: {
        whitelist: string[];
        providerUrl: string;
        ledgerCanisterId: string;
        ledgerHost?: string | undefined;
        noUnify?: boolean | undefined;
        host: string;
        dev: boolean;
        delegationModes?: DelegationMode[] | undefined;
        customDomain?: string | undefined;
    });
    get config(): {
        whitelist: string[];
        providerUrl: string;
        ledgerCanisterId: string;
        ledgerHost?: string | undefined;
        noUnify?: boolean | undefined;
        host: string;
        dev: boolean;
        delegationModes?: DelegationMode[] | undefined;
        customDomain?: string | undefined;
    };
    init(): Promise<import("neverthrow").Ok<{
        isConnected: boolean;
    }, never> | import("neverthrow").Err<never, {
        kind: InitError;
    }>>;
    isConnected(): Promise<boolean>;
    createActor<Service>(canisterId: string, idlFactory: IDL.InterfaceFactory): Promise<Result<ActorSubclass<Service>, {
        kind: CreateActorError;
    }>>;
    connect(): Promise<import("neverthrow").Ok<boolean, never> | import("neverthrow").Err<never, {
        kind: ConnectError;
    }>>;
    disconnect(): Promise<import("neverthrow").Ok<boolean, never> | import("neverthrow").Err<never, {
        kind: DisconnectError;
    }>>;
    requestTransfer(opts: {
        amount: number;
        to: string;
        symbol?: string;
        standard?: string;
        decimals?: number;
        fee?: number;
        memo?: bigint | Array<number>;
        createdAtTime?: Date;
        fromSubAccount?: number;
    }): Promise<import("neverthrow").Err<never, {
        kind: TransferError;
    }> | import("neverthrow").Ok<{
        height: number;
    }, never>>;
    requestTransferNFT(args: {
        tokenIdentifier: string;
        tokenIndex: number;
        canisterId: string;
        to: string;
        standard: string;
        fee?: number;
        memo?: bigint | Array<number>;
        createdAtTime?: Date;
        fromSubAccount?: number;
    }): Promise<import("neverthrow").Err<never, {
        kind: TransferError;
    }> | import("neverthrow").Ok<{
        blockHeight?: bigint | undefined;
        originPayload?: {
            to: string;
            amount: bigint;
            sendOpts?: Partial<import("@astrox/sdk-web/build/types").SendOpts> | undefined;
        } | undefined;
    }, never>>;
    queryBalance(): Promise<import("neverthrow").Ok<{
        amount: number;
        canisterId: string;
        decimals: number;
        name: string;
        symbol: string;
    }[], never> | import("neverthrow").Err<never, {
        kind: BalanceError;
    }>>;
}
export { AstroX, };
