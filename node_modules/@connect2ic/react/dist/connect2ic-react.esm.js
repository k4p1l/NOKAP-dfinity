import React, { createContext, useState, useContext, useEffect } from 'react';
import { useSelector } from '@xstate/react';
import { TransferError } from '@connect2ic/core';
import { err } from 'neverthrow';

const Connect2ICContext = /*#__PURE__*/createContext({});
const Connect2ICProvider = _ref => {
  let {
    children,
    client
  } = _ref;
  const [open, setOpen] = useState(false);
  const dialog = {
    open: () => setOpen(true),
    close: () => setOpen(false),
    isOpen: open
  };
  return /*#__PURE__*/React.createElement(Connect2ICContext.Provider, {
    value: {
      client,
      dialog
    }
  }, children);
};

const useConnect = function () {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  // TODO: handle
  const {
    onConnect = () => {},
    onDisconnect = () => {}
  } = props;
  const {
    client
  } = useContext(Connect2ICContext);
  const {
    principal,
    activeProvider,
    status
  } = useSelector(client._service, state => ({
    principal: state.context.principal,
    activeProvider: state.context.activeProvider,
    status: state.value
  }));
  useEffect(() => {
    const unsub = client.on("connect", onConnect);
    const unsub2 = client.on("disconnect", onDisconnect);
    return () => {
      unsub();
      unsub2();
    };
  }, [client]);
  return {
    principal,
    activeProvider,
    status,
    isInitializing: client._service.state?.matches({
      idle: "initializing"
    }) ?? false,
    isConnected: client._service.state?.matches({
      idle: "connected"
    }) ?? false,
    isConnecting: client._service.state?.matches({
      idle: "connecting"
    }) ?? false,
    isDisconnecting: client._service.state?.matches({
      idle: "disconnecting"
    }) ?? false,
    isIdle: client._service.state?.matches({
      idle: "idle"
    }) ?? false,
    connect: provider => {
      client.connect(provider);
    },
    cancelConnect: () => {
      client.cancelConnect();
    },
    disconnect: () => {
      client.disconnect();
    }
  };
};

// TODO: ??
// @ts-ignore
const useCanister = function (canisterName) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    mode: "auto" // "anonymous" | "connected"
  };

  const {
    mode
  } = options;
  const {
    client
  } = useContext(Connect2ICContext);
  const anonymousActorResult = useSelector(client._service, state => state.context.anonymousActors[canisterName]);
  const actorResult = useSelector(client._service, state => state.context.actors[canisterName]);
  const canisterDefinition = useSelector(client._service, state => state.context.canisters[canisterName]);
  const {
    isConnected
  } = useConnect();
  const signedIn = isConnected && actorResult && mode !== "anonymous";
  const actor = signedIn ? actorResult : anonymousActorResult;
  return [actor.isOk() ? actor.value : undefined, {
    error: actor.isErr() ? actor.error : undefined,
    // TODO: ?
    loading: !actor,
    canisterDefinition
  }];
};

const useWallet = () => {
  const {
    client
  } = useContext(Connect2ICContext);
  const activeProvider = useSelector(client._service, state => state.context.activeProvider);
  const supportsWallet = !!activeProvider?.meta.features.includes("wallet");
  const {
    isConnected
  } = useConnect();
  const wallet = isConnected && supportsWallet ? activeProvider : undefined;
  return [wallet];
};

const useBalance = () => {
  // TODO: check if supported or not
  const [wallet] = useWallet();
  const {
    activeProvider
  } = useConnect();
  const [assets, setAssets] = useState();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState();
  const refetch = async () => {
    if (!wallet || !activeProvider) {
      setAssets(undefined);
      return;
    }
    const result = await activeProvider.queryBalance?.();
    result.match(assets => {
      setAssets(assets);
    }, error => {
      setError(error);
    });
    setLoading(false);
    return result;
  };
  useEffect(() => {
    if (!wallet) {
      setAssets(undefined);
      return;
    }
    refetch();
  }, [wallet]);
  return [assets, {
    loading,
    error,
    refetch
  }];
};

const useDialog = function () {
  const {
    dialog
  } = useContext(Connect2ICContext);
  return dialog;
};

const useProviders = () => {
  const {
    client
  } = useContext(Connect2ICContext);
  const providers = useSelector(client._service, state => state.context.providers);
  return providers ?? [];
};

const useSignMessage = _ref => {
  let {
    message
  } = _ref;
  // TODO: check if supported or not
  const {
    activeProvider
  } = useConnect();
  const [wallet] = useWallet();
  const signMessage = () => {
    if (!wallet || !activeProvider) {
      return;
    }
    activeProvider.signMessage?.({
      message
    });
  };
  const loading = false;
  const error = false;
  return [signMessage, {
    loading,
    error
  }];
};

const useTransfer = _ref => {
  let {
    amount,
    to,
    from = undefined
  } = _ref;
  // TODO: check if supported or not
  const [wallet] = useWallet();
  const {
    activeProvider,
    principal
  } = useConnect();
  const [loading, setLoading] = useState(false);
  const [payload, setPayload] = useState();
  const [error, setError] = useState();
  const transfer = async () => {
    if (!wallet || !activeProvider) {
      return err({
        kind: TransferError.NotConnected
      });
    }
    setLoading(true);
    const result = await activeProvider.requestTransfer({
      amount,
      to
    });
    result.match(payload => {
      // TODO: ?
      setPayload(payload);
    }, error => {
      setError(error);
    });
    setLoading(false);
    return result;
  };
  return [transfer, {
    loading,
    error
  }];
};

const useClient = () => {
  const {
    client
  } = useContext(Connect2ICContext);
  return client;
};

//@ts-ignore
const isICX = !!window.icx;
const ConnectButton = props => {
  const {
    style = {},
    dark = false,
    onConnect = () => {},
    onDisconnect = () => {},
    children
  } = props;
  const dialog = useDialog();
  const {
    disconnect,
    isConnected,
    connect
  } = useConnect({
    onConnect,
    onDisconnect
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, !isConnected ? /*#__PURE__*/React.createElement("button", {
    onClick: () => isICX ? connect("icx") : dialog.open(),
    style: style,
    className: "connect-button"
  }, children ?? "Connect") : null, isConnected ? /*#__PURE__*/React.createElement("button", {
    onClick: disconnect,
    style: style,
    className: "connect-button"
  }, children ?? "Disconnect") : null);
};
var ConnectButton$1 = ConnectButton;

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

const ConnectDialog = props => {
  const {
    onClose = () => {
      dialog.close();
    },
    children,
    dark
  } = props;
  const dialog = useDialog();
  const providers = useProviders();
  const {
    connect,
    isConnected
  } = useConnect();
  useEffect(() => {
    if (isConnected) {
      dialog.close();
    }
  }, [isConnected]);
  useEffect(() => {
    if (dialog.isOpen) {
      document.body.style.overflow = "hidden";
    }
    if (!dialog.isOpen) {
      document.body.style.overflow = "unset";
    }
  }, [dialog.isOpen]);
  useEffect(() => {
    const handleEsc = event => {
      if (event.keyCode === 27) {
        dialog.close();
      }
    };
    window.addEventListener("keydown", handleEsc);
    return () => {
      window.removeEventListener("keydown", handleEsc);
    };
  }, []);
  const onClickInside = e => {
    e.stopPropagation();
  };
  return dialog.isOpen ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    className: `dialog-styles ${dark ? "dark" : "light"}`,
    onClick: onClose
  }, /*#__PURE__*/React.createElement("div", {
    onClick: onClickInside,
    className: "dialog-container"
  }, /*#__PURE__*/React.createElement("div", null, providers.map(provider => {
    return /*#__PURE__*/React.createElement("button", _extends({
      key: provider.meta.id,
      onClick: () => connect(provider.meta.id),
      className: `button-styles ${provider.meta.id}-styles`
    }, props), /*#__PURE__*/React.createElement("img", {
      className: "img-styles",
      src: dark ? provider.meta.icon.dark : provider.meta.icon.light
    }), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("span", {
      className: "button-label"
    }, provider.meta.name)));
  }))))) : null;
};
var ConnectDialog$1 = ConnectDialog;

export { Connect2ICContext, Connect2ICProvider, ConnectButton$1 as ConnectButton, ConnectDialog$1 as ConnectDialog, useBalance, useCanister, useClient, useConnect, useDialog, useProviders, useSignMessage, useTransfer, useWallet };
